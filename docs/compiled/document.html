<!DOCTYPE html>
<html>
<head>
<title>MarkdownPad Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 80%;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>SimpleDTD</h1>
Autori: Matúš Barabás, David Tran Duc
<br>Podiel práce: 50%/50%

<h2>BNF</h2>
<pre><code>dtddocument ::= declaration {declaration} .
declaration ::= attrdecl | elemdecl .
elemdecl ::= '&lt;!ELEMENT' name ('EMPTY' | 'ANY' | '(#PCDATA)' | elemchild) '&gt;' .
elemchild ::= '('(choice | seq)['?' | '*' | '+'] ')' .
choice ::= '(' cp ['|' cp] ')' .
seq ::= '(' cp {',' cp} ')' .
cp ::= (name | choice | seq) ['?' | '*' | '+'].
attrdecl ::= '&lt;!ATTLIST' name {name attrtype defaultdecl} '&gt;' .
attrtype::= 'CDATA' | 'NMTOKEN' | 'IDREF' | '(' word ['|' word] ')' .
defaultdecl ::= '#REQUIRED' | '#IMPLIED' | (['#FIXED'] '&quot;' word {word} '&quot;' ) .
name ::= (letter| '_' | ':') {namechar} .
namechar ::= letter| digit| '.' | '-' | '_' | ':' .
letter::= 'A' | .. | 'Z' | 'a' | .. | 'z' .
number::= digit {digit} .
digit::= '0' | .. | '9' .
word ::= char {char} .
char::= letter | digit | $ | % | ~
</code></pre>

<p>Zo zadanej gramatiky nie je možné zostrojiť LL(1) automat. Ak nastane prípad, že budú za sebou nasledovať 2 &quot;name&quot; alebo &quot;word&quot;,  tak by sme nevedeli zistiť, či sa jedná len o jedno slovo, alebo dve slová. Potrebujeme mať indikátor toho, kedy slovo začína alebo končí:</p>
<pre><code>attrdecl ::= '&lt;!ATTLIST' name {name attrtype defaultdecl} '&gt;' .
defaultdecl ::= '#REQUIRED' | '#IMPLIED' | (['#FIXED'] '&quot;' word {word} '&quot;' ) .
</code></pre>
<p>Vykonali sme nasledovnú zmenu, pridali sme &quot;|&quot; medzi slová &quot;name&quot; a &quot;word&quot;:</p>
<pre><code>attrdecl ::= '&lt;!ATTLIST' name {'|' name attrtype defaultdecl} '&gt;' .
defaultdecl ::= '#REQUIRED' | '#IMPLIED' | (['#FIXED'] '&quot;' word { '|' word} '&quot;' ) .
</code></pre>
<h2>BNF po úprave</h2>
<pre><code>dtddocument ::= declaration {declaration} .
declaration ::= attrdecl | elemdecl .
elemdecl ::= '&lt;!ELEMENT' name ('EMPTY' | 'ANY' | '(#PCDATA)' | elemchild) '&gt;' .
elemchild ::= '('(choice | seq)['?' | '*' | '+'] ')' .
choice ::= '(' cp ['|' cp] ')' .
seq ::= '(' cp {',' cp} ')' .
cp ::= (name | choice | seq) ['?' | '*' | '+'].
attrdecl ::= '&lt;!ATTLIST' name {name attrtype defaultdecl} '&gt;' .
attrtype::= 'CDATA' | 'NMTOKEN' | 'IDREF' | '(' word ['|' word] ')' .
defaultdecl ::= '#REQUIRED' | '#IMPLIED' | (['#FIXED'] '&quot;' word {word} '&quot;' ) .
name ::= (letter| '_' | ':') {namechar} .
namechar ::= letter| digit| '.' | '-' | '_' | ':' .
letter::= 'A' | .. | 'Z' | 'a' | .. | 'z' .
number::= digit {digit} .
digit::= '0' | .. | '9' .
word ::= char {char} .
char::= letter | digit | $ | % | ~
</code></pre>

<h2>Príklady viet z jazyka</h2>
<pre><code>&lt;!ELEMENT note ((to,from,heading,body))&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre>

<pre><code>&lt;!ATTLIST sipvs | FiiT IDREF #REQUIRED&gt;
</code></pre>

<pre><code>&lt;!ELEMENT :w.i-n.t-e.r.._..i-s.._..h.e-r.e: (((or* | not*)?))&gt;
</code></pre>

<p>Ďalšie testovacie vstupy a ich očakávané výstupy sú v kapitole nižšie.</p>
<h2>Prepis pravidiel z BNF do pravidiel bezkontextovej gramatiky</h2>
<pre><code>DTDOC -&gt; DEC | DEC DTDOC
DEC -&gt; ATTRDEC | ELEMDEC
ELEMDEC -&gt; &lt;!ELEMENT NAME EMPTY &gt; |
           &lt;!ELEMENT NAME ANY &gt; |
           &lt;!ELEMENT NAME (#PCDATA) &gt; |
           &lt;!ELEMENT NAME ELEMCHILD &gt;
ELEMCHILD -&gt; ( CH ) | ( SEQ ) |
             ( CH ? ) | ( SEQ ? ) |
             ( CH * ) | ( SEQ * ) |
             ( CH + ) | ( SEQ + )
CH -&gt; ( CP ) | ( CP '|' CP )
SEQ -&gt; ( SEQ' )
SEQ' -&gt; CP | CP , SEQ'
CP -&gt; NAME | CH | SEQ |
      NAME ? | CH ? | SEQ ? |
      NAME * | CH * | SEQ * |
      NAME + | CH + | SEQ +
ATTRDEC -&gt; &lt;!ATTLIST ATTRDEC' &gt;
ATTRDEC' -&gt; NAME ATTRDEC''
ATTRDEC'' -&gt; NAME ATTRTYPE DEFAULTDEC ATTRDEC'' | ε
ATTRTYPE -&gt; CDATA | NMTOKEN | IDREF | ( WORD ) | ( WORD '|' WORD )
DEFAULTDEC -&gt; #REQUIRED | #IMPLIED | #FIXED &quot; DEFAULTDEC' &quot; | &quot; DEFAULTDEC' &quot;
DEFAULTDEC' -&gt; WORD | WORD DEFAULTDEC'
NAME -&gt; LET NAME' | _ NAME' | : NAME'
NAME' -&gt; NAMECHAR NAME' | ε
NAMECHAR -&gt; LET | DIG | . | - | _ | :
LET -&gt; A-Z | a-z
NUMBER -&gt; DIG | DIG NUMBER
DIG -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
WORD -&gt; CHAR | CHAR WORD
CHAR -&gt; LET | DIG | $ | ~ | %
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; DTDOC</h5>
<pre><code>DTDOC -&gt; DEC DTDOC'
DTDOC' -&gt; DTDOC | ε
DEC -&gt; ATTRDEC | ELEMDEC
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; ELEMDEC</h5>
<pre><code>ELEMDEC -&gt; &lt;!ELEMENT NAME ELEMDEC'
ELEMDEC' -&gt; EMPTY &gt; | ANY &gt; | (#PCDATA) &gt; | ELEMCHILD &gt;
</code></pre>

<h5>Odstránenie dvojitej ľavej faktorizácie -&gt; ELEMCHILD</h5>
<pre><code>ELEMCHILD -&gt; ( ELEMCHILD''
ELEMCHILD' -&gt; ? ) | * ) | + ) | )
ELEMCHILD'' -&gt; CH ELEMCHILD' | SEQ ELEMCHILD'
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; CH</h5>
<pre><code>CH -&gt; ( CP CH'
CH' -&gt; '|' CP ) | )
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; SEQ'</h5>
<pre><code>SEQ' -&gt; CP SEQ''
SEQ'' -&gt; , SEQ' | ε
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; CP</h5>
<pre><code>CP -&gt; NAME CP' | CH CP' | SEQ CP'
CP' -&gt; ? | *  | + | ε
</code></pre>

<h5>Substitucia CH a SEQ</h5>
<pre><code>ELEMCHILD'' -&gt; ( CP CH' ELEMCHILD' | ( SEQ' ) ELEMCHILD'
CP -&gt; NAME CP' | ( CP CH' CP' | ( SEQ' ) CP'
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; ELEMCHILD''</h5>
<pre><code>ELEMCHILD'' -&gt; ( ELEMCHILD'''
ELEMCHILD''' -&gt; CP CH' ELEMCHILD' | SEQ' ) ELEMCHILD'
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; CP</h5>
<pre><code>CP -&gt; NAME CP' | ( CP''
CP' -&gt; ? | * | + | ε
CP'' -&gt; CP CH' CP' | SEQ' ) CP'
</code></pre>

<h5>Substitúcia SEQ'</h5>
<pre><code>ELEMCHILD''' -&gt; CP CH' ELEMCHILD' | CP SEQ'' ) ELEMCHILD'
SEQ'' -&gt; , CP SEQ'' | ε
CP'' -&gt; CP CH' CP' | CP SEQ'' ) CP'
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; ELEMCHILD'''</h5>
<pre><code>ELEMCHILD''' -&gt; CP ELEMCHILD''''
ELEMCHILD'''' -&gt; CH' ELEMCHILD' | SEQ'' ) ELEMCHILD'
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; CP''</h5>
<pre><code>CP'' -&gt; CP CP'''
CP''' -&gt; CH' CP' | SEQ'' ) CP'
</code></pre>

<h5>Odstránenie epsilon -&gt; SEQ''</h5>
<pre><code>ELEMCHILD'''' -&gt; CH' ELEMCHILD' | SEQ'' ) ELEMCHILD' | ) ELEMCHILD'
SEQ'' -&gt; , CP SEQ'' | , CP
CP''' -&gt; CH' CP' | SEQ'' ) CP' | ) CP'
</code></pre>

<h5>Substitúcia CH' v ELEMCHILD'''' a CP'''</h5>
<pre><code>ELEMCHILD'''' -&gt; &amp; CP ) ELEMCHILD' | SEQ'' ) ELEMCHILD' | ) ELEMCHILD'
CP''' -&gt; '|' CP ) CP' | SEQ'' ) CP' | ) CP'
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; SEQ''</h5>
<pre><code>SEQ'' -&gt; , CP SEQ'''
SEQ''' -&gt; SEQ'' | ε
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; ATTRTYPE</h5>
<pre><code>ATTRTYPE -&gt; CDATA | NMTOKEN | IDREF | ( WORD ATTRTYPE'
ATTRTYPE' -&gt; ) | '|' WORD )
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; DEFAULTDEC'</h5>
<pre><code>DEFAULTDEC' -&gt; WORD DEFAULTDEC''
DEFAULTDEC'' -&gt; DEFAULTDEC' | ε
</code></pre>

<h5>Odstránenie ľavej faktorizácie -&gt; WORD</h5>
<pre><code>WORD -&gt; CHAR WORD'
WORD' -&gt; WORD | ε
CHAR -&gt; LET | DIG | $ | ~ | %
</code></pre>

<h5>Pridanie | do ATTRDEC' a Y, aby bola gramatika LL1</h5>
<pre><code>ATTRDEC' -&gt; NAME '|' ATTRDEC''
DEFAULTDEC' -&gt; WORD '|' DEFAULTDEC''
</code></pre>

<h5>Vyhodenie nedostupného pravidla NUMBER</h5>
<h5>Výsledná gramatika</h5>
<pre><code>DTDOC -&gt; DEC DTDOC'
DTDOC' -&gt; DTDOC | ε
DEC -&gt; ATTRDEC | ELEMDEC
ELEMDEC -&gt; &lt;!ELEMENT NAME ELEMDEC'
ELEMDEC' -&gt; EMPTY &gt; | ANY &gt; | (#PCDATA) &gt; | ELEMCHILD &gt;
ELEMCHILD -&gt; ( ELEMCHILD''
ELEMCHILD' -&gt; ? ) | * ) | + ) | )
ELEMCHILD'' -&gt; ( ELEMCHILD'''
ELEMCHILD''' -&gt; CP ELEMCHILD''''
ELEMCHILD'''' -&gt; '|' CP ) ELEMCHILD' | SEQ'' ) ELEMCHILD' | ) ELEMCHILD'
SEQ'' -&gt; , CP SEQ'''
SEQ''' -&gt; SEQ'' | ε
CP -&gt; NAME CP' | ( CP''
CP' -&gt; ? | * | + | ε
CP'' -&gt; CP CP'''
CP''' -&gt; '|' CP ) CP' | SEQ'' ) CP'  | ) CP'
ATTRDEC -&gt; &lt;!ATTLIST ATTRDEC' &gt;
ATTRDEC' -&gt; NAME '|' ATTRDEC''
ATTRDEC'' -&gt; NAME ATTRTYPE DEFAULTDEC ATTRDEC'' | ε
ATTRTYPE -&gt; CDATA | NMTOKEN | IDREF | ( WORD ATTRTYPE'
ATTRTYPE' -&gt; ) | '|' WORD )
DEFAULTDEC -&gt; #REQUIRED | #IMPLIED | #FIXED &quot; DEFAULTDEC' &quot; | &quot; DEFAULTDEC' &quot;
DEFAULTDEC' -&gt; WORD '|' DEFAULTDEC''
DEFAULTDEC'' -&gt; DEFAULTDEC' | ε
NAME -&gt; LET NAME'  | _ NAME' | : NAME'
NAME' -&gt; NAMECHAR NAME' | ε
NAMECHAR -&gt; LET | DIG | . | - | _ | :
LET -&gt; a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z  | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
DIG -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
WORD -&gt; CHAR WORD'
WORD' -&gt; WORD | ε
CHAR -&gt; LET | DIG | @ | ~ | %
</code></pre>

<h2>Overenie LL(1)</h2>
<h3>First</h3>
<pre><code>F1(DTDOC) = F1(DEC) = {&lt;!ATTLIST, &lt;!ELEMENT}
F1(DTDOC') = F1(DTDOC) U {ε} = {&lt;!ATTLIST, &lt;!ELEMENT, ε}
F1(DEC) = F1(ATTRDEC) U F1(ELEMDEC) = {&lt;!ATTLIST, &lt;!ELEMENT}
F1(ELEMDEC) = {&lt;!ELEMENT}
F1(ELEMDEC') = {EMPTY, ANY, (#PCDATA)} U F1(ELEMCHILD) = {EMPTY, ANY, (#PCDATA), (}
F1(ELEMCHILD) = {(}
F1(ELEMCHILD') = {?, *, +, )}
F1(ELEMCHILD'') = F1(( ELEMCHILD''') = {(}
F1(ELEMCHILD''') = F1(CP ELEMCHILD'''') = F1(CP) = {_, :, a-z, A-Z, (}
F1(ELEMCHILD'''') = {|, )} U F1(SEQ'') = {|, ), ','}
F1(SEQ'') = {','}
F1(SEQ''') = F1(SEQ'') U {ε} = {',', ε}
F1(CP) = F1(NAME) U {(} = {_, :, a-z, A-Z, (}
F1(CP') = F1(?) U F1(*) U F1(+) U {ε} = {?, *, +, ε}
F1(CP'') = F1(CP) = {_, :, a-z, A-Z, (}
F1(CP''') = {|, )} U F1(SEQ'') = {|, ), ,}
F1(ATTRDEC) = {&lt;!ATTLIST}
F1(ATTRDEC') = F1(NAME) = {_, :, a-z, A-Z}
F1(ATTRDEC'') = F1(NAME) U {ε} = {_, :, a-z, A-Z, ε}
F1(ATTRTYPE) = {CDATA, NMTOKEN, IDREF, (}
F1(ATTRTYPE') = {), |}
F1(DEFAULTDEC) = {#REQUIRED, #IMPLIED, #FIXED, &quot;}
F1(DEFAULTDEC') = F1(WORD) = {a-z, A-Z, 0-9, @, ~, %}
F1(DEFAULTDEC'') = F1(DEFAULTDEC') U {ε} = {a-z, A-Z, 0-9, @, ~, %, ε}
F1(NAME) = F1(LET) U {_, :} = {_, :, a-z, A-Z}
F1(NAME') = F1(NAMECHAR) U {ε} = {., -, _, :, a-z, A-Z, 0-9, ε}
F1(NAMECHAR) = F1(LET) U F1(DIG) U {., -, _, :} = {., -, _, :, a-z, A-Z, 0-9}
F1(LET) = {a-z, A-Z}
F1(DIG) = {0-9}
F1(WORD) = F1(CHAR) = {a-z, A-Z, 0-9, @, ~, %}
F1(WORD') = F1(WORD) U {ε} = {a-z, A-Z, 0-9, @, ~, %, ε}
F1(CHAR) = F1(LET) U F1(DIG) U {@, ~, %} = {a-z, A-Z, 0-9, @, ~, %}
</code></pre>

<h3>Follow</h3>
<pre><code>FO1(DTDOC) = FO1(DTDOC') = FO1(DTDOC) = {$}
FO1(DTDOC') = FO1(DTDOC) = {$}
FO1(DEC) = F1(DTDOC') \ {ε} U FO1(DTDOC) = {&lt;!ATTLIST, &lt;!ELEMENT, $}
FO1(ELEMDEC) = FO1(DEC) = {&lt;!ATTLIST, &lt;!ELEMENT, $}
FO1(ELEMDEC') = FO1(ELEMDEC) = FO1(DEC) = {&lt;!ATTLIST, &lt;!ELEMENT, $}
FO1(ELEMCHILD) = {&gt;}
FO1(ELEMCHILD') = FO1(ELEMCHILD'''') = {&gt;}
FO1(ELEMCHILD'') = FO1(ELEMCHILD) = {&gt;}
FO1(ELEMCHILD''') = FO1(ELEMCHILD'') = {&gt;}
FO1(ELEMCHILD'''') = FO1(ELEMCHILD''') = FO1(ELEMCHILD'') = {&gt;}
FO1(SEQ'') = {)} U FO1(SEQ''') = {)}
FO1(SEQ''') = FO1(SEQ'') = {)} U FO1(SEQ''') = {)}
FO1(CP) = F1(ELEMCHILD'''') U {)} U F1(SEQ''')\ {ε} U FO1(SEQ'') U F1(CP''') = {), ',', |}
FO1(CP') = FO1(CP) U FO1(CP''') = {), ',', |}
FO1(CP'') = FO1(CP) = {), ',', |}
FO1(CP''') = FO1(CP'') = {), ',', |}
FO1(ATTRDEC) = FO1(DEC) = {&lt;!ATTLIST, &lt;!ELEMENT, $}
FO1(ATTRDEC') = {&gt;}
FO1(ATTRDEC'') = FO1(ATTRDEC') = {&gt;}
FO1(ATTRTYPE) = F1(DEFAULTDEC) = {#REQUIRED, #IMPLIED, #FIXED, &quot;}
FO1(ATTRTYPE') = FO1(ATTRTYPE) = {#REQUIRED, #IMPLIED, #FIXED, &quot;}
FO1(DEFAULTDEC) = F1(ATTRDEC'')\ {ε} U FO1(ATTRDEC'') = {_, :, a-z, A-Z, &gt;}
FO1(DEFAULTDEC') = {&quot;} U FO1(DEFAULTDEC'') = {&quot;}
FO1(DEFAULTDEC'') = FO1(DEFAULTDEC') = {&quot;}
FO1(NAME) = F1(ELEMDEC') U F1(CP')\ {ε} U FO1(CP) U {|} U F1(ATTRTYPE) = {EMPTY, ANY, (#PCDATA), (, ?, *, +, ), ',', |, CDATA, NMTOKEN, IDREF}
FO1(NAME') = FO1(NAME) = {EMPTY, ANY, (#PCDATA), (, ?, *, +, ), ',', |, CDATA, NMTOKEN, IDREF}
FO1(NAMECHAR) = F1(NAME')\ {ε} U FO1(NAME') = {., -, _, :, a-z, A-Z, 0-9, EMPTY, ANY, (#PCDATA), (, ?, *, +, ), ',', |, CDATA, NMTOKEN, IDREF}
FO1(LET) = F1(NAME')\ {ε} U FO1(NAME) U FO1(NAMECHAR) U FO1(CHAR) = {., -, _, :, a-z, A-Z, 0-9, EMPTY, ANY, (#PCDATA), (, ?, *, +, ), ',', |, CDATA, NMTOKEN, IDREF, @, ~, %}
FO1(DIG) = FO1(NAMECHAR) U FO1(CHAR) = {., -, _, :, a-z, A-Z, 0-9, EMPTY, ANY, (#PCDATA), (, ?, *, +, ), ',', |, CDATA, NMTOKEN, IDREF, @, ~, %}
FO1(WORD) = F1(ATTRTYPE') U {), |} U FO1(WORD') = {), |}
FO1(WORD') = FO1(WORD) = {), |}
FO1(CHAR) = F1(WORD')\ {ε} U FO1(WORD) = {a-z, A-Z, 0-9, @, ~, %, ), |}
</code></pre>

<h3>First-First konflikty</h3>
<pre><code>F1(DTDOC) ∩ {ε} = {&lt;!ATTLIST, &lt;!ELEMENT} ∩ {ε} = ∅
F1(ATTRDEC) ∩ F1(ELEMDEC) = {&lt;!ATTLIST} ∩ {&lt;!ELEMENT} = ∅ 
F1(EMPTY &gt;) ∩ F1(ANY &gt;) ∩ F1((#PCDATA) &gt;) ∩ F1(ELEMCHILD &gt;) = {EMPTY} ∩ {ANY} ∩ {(#PCDATA)} ∩ {(} = ∅
F1(? )) ∩ F1(* )) F1(+ )) F1()) = {?} ∩ {*} ∩ {+} ∩ {)} = ∅
F1('|' CP ) ELEMCHILD') ∩ F1(SEQ'' ) ELEMCHILD') ∩ F1() ELEMCHILD') = {|} ∩ {','} ∩ {)} = ∅
F1(SEQ'') ∩ {ε} = {','} ∩ {ε} = ∅
F1(NAME CP') ∩ F1(( CP'') = F1(NAME) ∩ {(} = {_, :, a-z, A-Z} ∩ {(} =  ∅
F1(?) ∩ F1(*) ∩ F1(+) ∩ {ε} = {?} ∩ {*} ∩ {+} ∩ {ε} = ∅
F1('|' CP ) CP') ∩ F1(SEQ'' ) CP') ∩ F1() CP') = {|} ∩ {','} ∩ {)} = ∅
F1(NAME ATTRTYPE DEFAULTDEC ATTRDEC'') ∩ {ε} = F1(NAME) ∩ {ε} = {_, :, a-z, A-Z}  ∩ {ε} =  ∅
F1(CDATA) ∩ F1(NMTOKEN) ∩ F1(IDREF) ∩ F1(( WORD ATTRTYPE') = {CDATA} ∩ {NMTOKEN} ∩ {IDREF} ∩ {(} = ∅
F1()) ∩ F1('|' WORD )) = {)} ∩ {|} = ∅
F1(#REQUIRED) ∩ F1(#IMPLIED) ∩ F1(#FIXED &quot; DEFAULTDEC' &quot;) ∩ F1(&quot; DEFAULTDEC' &quot;) = {#REQUIRED} ∩ {#IMPLIED} ∩ {#FIXED} ∩ {&quot;}  = ∅
F1(DEFAULTDEC') ∩ {ε} = {a-z, A-Z, 0-9, @, ~, %} ∩ {ε} = ∅
F1(LET NAME') ∩ F1(_ NAME') ∩ F1(: NAME') = F1(LET) ∩ {_} ∩ {:} = {a-z, A-Z} ∩ {_} ∩ {:} = ∅
F1(NAMECHAR NAME') ∩ {ε} = F1(NAMECHAR) {ε} = {., -, _, :, a-z, A-Z, 0-9} ∩ {ε} = ∅
F1(LET) ∩ F1(DIG) ∩ F1(.) ∩ F1(-) ∩ F1(_) ∩ F1(:) = {a-z, A-Z} ∩ {0-9} ∩ {.} ∩ {-} ∩ {_} ∩ {:} = ∅
F1(a) ∩ F1(b) ... F1(Z) = {a} ∩ {b} ... ∩ {Z} = ∅
F1(0) ∩ F1(1) ... F1(9) = {0} ∩ {1} ... ∩ {9} = ∅
F1(WORD) ∩ {ε} = {a-z, A-Z, 0-9, @, ~, %} ∩ {ε} = ∅
F1(LET) ∩ F1(DIG) ∩ F1(@) ∩ F1(~) ∩ F1(%) = {a-z, A-Z} ∩ {0-9} ∩ {@} ∩ {~} ∩ {%} = ∅

No First-First conflicts exist.
</code></pre>

<h3>First-Follow konflikty</h3>
<pre><code>Nullable: {DTDOC', SEQ''', CP', ATTRDEC'', DEFAULTDEC'', NAME', WORD'}

F1(DTDOC') ∩ FO1(DTDOC') = {&lt;!ATTLIST, &lt;!ELEMENT, ε} ∩ {$} = ∅
F1(SEQ''') ∩ FO1(SEQ''') = {',', ε} ∩ {)} = ∅
F1(CP') ∩ FO1(CP') = {?, *, +, ε} ∩ {), ',', |} = ∅
F1(ATTRDEC'') ∩ FO1(ATTRDEC'') = {_, :, a-z, A-Z, ε} ∩ {&gt;} = ∅
F1(DEFAULTDEC'') ∩ FO1(DEFAULTDEC'') = {a-z, A-Z, 0-9, @, ~, %, ε} ∩ {&quot;} = ∅
F1(NAME') ∩ FO1(NAME') = {., -, _, :, a-z, A-Z, 0-9, ε} ∩ {EMPTY, ANY, (#PCDATA), (, ?, *, +, ), ',', |, CDATA, NMTOKEN, IDREF} = ∅
F1(WORD') ∩ FO1(WORD') = {a-z, A-Z, 0-9, @, ~, %, ε} ∩  {), |} = ∅

No First-Follow conflicts exist.
</code></pre>

<h2>Parsing table</h2>
<a href="parsing_table.html">Link na tabulku</a>
<p>Náhľad tabuľky:</p>
<embed style="width: 100%; height: 900px" src="parsing_table.html">
<h1>Program</h1>
<p>Implementovali sme zotavenie z chýb aj pre lexikálny aj syntaktický analyzátor. Toto zotavovanie z chýb je možné zapnúť pomocou príznakov. Taktiež je možné zapnúť krokovanie programu.</p>
<p>Lexikálny analyzátor sa dokáže zotaviť z jednoduchých preklepov vo vyhradených slovách, ako napríklad &quot;&lt;ELEMENT&quot;. Zisťuje sa tu Levenshteinova vzdialenosť, ak je menšia alebo rovná dva, tak považujeme dané slovo za preklep.</p>
<p>Syntaktický analyzátor sa dokáže zotaviť zo situácie, kedy používateľ zabudne napísať zátvorku (napr. &lt;!ELEMENT note (to,from,heading,body))&gt;). Analyzátor pri zotavení buď vyhodí symbol na vrchu zásobníka alebo vyhodí vrchol a pridá stav. Deje sa tak na základe toho, či chýba pravá alebo ľavá zátvorka.</p>
<h2>Použitie</h2>
<pre><code>basicDTD, usage:
  -h            shows this help
  -p [path]     path to the input file, if unspecified, takes in input.txt
  -l            enables automatic fixing of typos of reserved keyword, based on Levenshtein distance
  -r            enables recovery from incorrect usage of round brackets
  -L            enables step by step execution of lexical analyzer
  -S            enables step by step execution of syntax analyzer
</code></pre>

<h2>Testovacie vstupy a výstupy</h2>
<h3>Examples</h3>
<p>Example 1:</p>
<pre><code>&lt;!ELEMENT note ((to,from,heading,body))&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre>

<p>should be</p>
<pre><code>green regardless of flags
</code></pre>

<p>Example 2:</p>
<pre><code>&lt;!ELEMENT note ((to,from,heading,body))&gt;
&lt;!EEMENT to (#PCDATA)&gt;
&lt;!ELEEMNT from (#PCDATA)&gt;
&lt;!ELEMENTE heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre>

<p>should be</p>
<pre><code>green with    flag -l
red   without flag -l : Parsing table out of bounds.
</code></pre>

<p>Example 3:</p>
<pre><code>&lt;!ELEMENT note (to,from,heading,body))&gt;
&lt;!ELEMENT note ((to,from,heading,body)&gt;
&lt;!ELEMENT note (((to,from,heading,body))&gt;
</code></pre>

<p>should be</p>
<pre><code>green with    flag -s
red   without flag -s : No match in parsing table.
</code></pre>

<p>Example 4:</p>
<pre><code>&lt;!ELEMENT note (to,from,heading,body)*)&gt;
&lt;!EEMENT to (#PCDATA)&gt;
&lt;!ELEEMNT from (#PCDATA)&gt;
&lt;!ELEMENTE heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre>

<p>should be</p>
<pre><code>green with    flag -ls
red   with    flag -s  : Parsing table out of bounds.
      with    flag -l  : No match in parsing table.
      without flags    : No match in parsing table.
</code></pre>

<p>Example 5:</p>
<pre><code>&lt;!ATTLIST sipvs | FiiT IDREF #REQUIRED&gt;
</code></pre>

<p>should be</p>
<pre><code>green regardless of flags
</code></pre>

<p>Example 6:</p>
<pre><code>&lt;!ELEMENT :w.i-n.t-e.r.._..i-s.._..h.e-r.e: (((or* | not*)?))&gt;
</code></pre>

<p>should be</p>
<pre><code>green regardless of flags
</code></pre>

<p>Example 7:</p>
<pre><code>&lt;!ATTLIST santa:clause- | s.t.r.o.m.c.e.k (ab|cd) #FIXED &quot;@%|~0|&quot;&gt;
</code></pre>

<p>should be</p>
<pre><code>green regardless of flags
</code></pre>

<p>Example 8:</p>
<pre><code>&lt;!ELEMENT : ANY&gt;
&lt;!ELEMENT _ ANY&gt;
&lt;!ELEMENT x ANY&gt;
&lt;!ATTLIST : |&gt;
&lt;!ATTLIST _ |&gt;
&lt;!ATTLIST x |&gt;
</code></pre>

<p>should be</p>
<pre><code>green regardless of flags
</code></pre>

<p>Example 9:</p>
<pre><code>&lt;!ELEMENT cHrIsTmAs ((:santa007+ | ((fiit,no:more))*)?)&gt;
</code></pre>

<p>should be</p>
<pre><code>green regardless of flags
</code></pre>

<p>Example 10:</p>
<pre><code>&lt;!ATTLIST _ | : (svk | cz) &quot;sweden|finland|&quot;&gt;
</code></pre>

<p>should be</p>
<pre><code>green regardless of flags
</code></pre>


</body>
</html>
